/***************************************************************************//**
  @file     ModulatorV1.c
  @brief    modulator functions
  @author   Grupo 5
 ******************************************************************************/

#include "ModuladorV1.h"
#include "DAC.h"
#include "PIT.h"
#include "Queues/queue.h"


/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

#define		UART_LENGTH		11
#define		LSB_BIT			0b00000001
#define		SINE_2200_OFFSET		22
#define		SINE_1200_OFFSET		12

//LENXBIT sale de hacer la cuenta SINSAMPLES/6, es decir representa cuantas loops debo hacer recorriendo con stepsize de 6 en 6.
#define LENXBIT	55
#define MSGLEN 	(UART_LENGTH*LENXBIT)


void (*MsgSentClb)(void);

/*******************************************************************************
 * VARIABLES WITH LOCAL SCOPE
 ******************************************************************************/

static uint32_t duty = 190;
static uint32_t period = 379;

static uint16_t sine[] = {
		2028,2047,2066,2085,2105,2124,2143,2163,2182,2201,2220,2239,2259,2278,2297,2316,2335,2354,2373,2392,2411,2430,2449,2468,2487,2506,2524,2543,2562,2580,2599,2617,
		2636,2654,2672,2691,2709,2727,2745,2763,2781,2799,2817,2834,2852,2870,2887,2905,2922,2939,2957,2974,2991,3008,3024,3041,3058,3074,3091,3107,3124,3140,3156,3172,
		3188,3204,3219,3235,3250,3266,3281,3296,3311,3326,3341,3355,3370,3384,3398,3413,3427,3441,3454,3468,3481,3495,3508,3521,3534,3547,3560,3572,3585,3597,3609,3621,
		3633,3645,3656,3668,3679,3690,3701,3712,3723,3733,3743,3754,3764,3774,3783,3793,3802,3812,3821,3830,3838,3847,3855,3864,3872,3880,3887,3895,3903,3910,3917,3924,
		3931,3937,3943,3950,3956,3962,3967,3973,3978,3983,3988,3993,3998,4002,4007,4011,4015,4018,4022,4025,4029,4032,4034,4037,4039,4042,4044,4046,4048,4049,4050,4052,
		4053,4054,4054,4055,4055,4055,4055,4055,4054,4054,4053,4052,4050,4049,4048,4046,4044,4042,4039,4037,4034,4032,4029,4025,4022,4018,4015,4011,4007,4002,3998,3993,
		3988,3983,3978,3973,3967,3962,3956,3950,3943,3937,3931,3924,3917,3910,3903,3895,3887,3880,3872,3864,3855,3847,3838,3830,3821,3812,3802,3793,3783,3774,3764,3754,
		3743,3733,3723,3712,3701,3690,3679,3668,3656,3645,3633,3621,3609,3597,3585,3572,3560,3547,3534,3521,3508,3495,3481,3468,3454,3441,3427,3413,3398,3384,3370,3355,
		3341,3326,3311,3296,3281,3266,3250,3235,3219,3204,3188,3172,3156,3140,3124,3107,3091,3074,3058,3041,3024,3008,2991,2974,2957,2939,2922,2905,2887,2870,2852,2834,
		2817,2799,2781,2763,2745,2727,2709,2691,2672,2654,2636,2617,2599,2580,2562,2543,2524,2506,2487,2468,2449,2430,2411,2392,2373,2354,2335,2316,2297,2278,2259,2239,
		2220,2201,2182,2163,2143,2124,2105,2085,2066,2047,2028,2008,1989,1970,1950,1931,1912,1892,1873,1854,1835,1816,1796,1777,1758,1739,1720,1701,1682,1663,1644,1625,
		1606,1587,1568,1549,1531,1512,1493,1475,1456,1438,1419,1401,1383,1364,1346,1328,1310,1292,1274,1256,1238,1221,1203,1185,1168,1150,1133,1116,1098,1081,1064,1047,
		1031,1014,997,981,964,948,931,915,899,883,867,851,836,820,805,789,774,759,744,729,714,700,685,671,657,642,628,614,601,587,574,560,
		547,534,521,508,495,483,470,458,446,434,422,410,399,387,376,365,354,343,332,322,312,301,291,281,272,262,253,243,234,225,217,208,
		200,191,183,175,168,160,152,145,138,131,124,118,112,105,99,93,88,82,77,72,67,62,57,53,48,44,40,37,33,30,26,23,
		21,18,16,13,11,9,7,6,5,3,2,1,1,0,0,0,0,0,1,1,2,3,5,6,7,9,11,13,16,18,21,23,
		26,30,33,37,40,44,48,53,57,62,67,72,77,82,88,93,99,105,112,118,124,131,138,145,152,160,168,175,183,191,200,208,
		217,225,234,243,253,262,272,281,291,301,312,322,332,343,354,365,376,387,399,410,422,434,446,458,470,483,495,508,521,534,547,560,
		574,587,601,614,628,642,657,671,685,700,714,729,744,759,774,789,805,820,836,851,867,883,899,915,931,948,964,981,997,1014,1031,1047,
		1064,1081,1098,1116,1133,1150,1168,1185,1203,1221,1238,1256,1274,1292,1310,1328,1346,1364,1383,1401,1419,1438,1456,1475,1493,1512,1531,1549,1568,1587,1606,1625,
		1644,1663,1682,1701,1720,1739,1758,1777,1796,1816,1835,1854,1873,1892,1912,1931,1950,1970,1989,2008
};


static uint8_t uartData[UART_LENGTH];
static uint8_t	char_index = UART_LENGTH;
static queue_uint8_t buffer;



static uint16_t counter;
/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/


/**
 * @brief
 */
static void send_data_to_modulate(void);


/**
 * @brief
 */
static void create_bit_frame(uint8_t data);


/*******************************************************************************
 *******************************************************************************
                        GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/


void Modulator_Init(void(*clb)(void))
{
	queue_Init_uint8(&buffer);
	counter = MSGLEN + 1;	// no data to be sent

	MsgSentClb = clb;

	DAC_init();

	PIT_init();

	PIT_set_Timer(0, 758, send_data_to_modulate);

	PIT_Start_Timer(0);
}



int8_t modulator_sendChar(uint8_t data)
{
	return push_Queue_Element_uint8(&buffer, data);
}


/*******************************************************************************
 *******************************************************************************
                        LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/


static void create_bit_frame(uint8_t data)
{
	uartData[0] = 0;
	uint8_t parity = 1;
	char_index = 0;

	uint8_t i;
	for(i = 1; i < UART_LENGTH - 2; i++)
	{
		uartData[i] = data & LSB_BIT;
		parity ^= uartData[i];
		data >>= 1;
	}

	uartData[UART_LENGTH - 2] = parity;
	uartData[UART_LENGTH - 1] = 1;
}

//Todo: configurar bien el tiempo del pit, ver cuando index debe ser igual a 0.
static void send_data_to_modulate(void)
{
	static uint16_t  index = 0;
	static uint16_t  step  = 0;


	//Condicion: enviando una palabra
	if(counter < MSGLEN)
	{
		//Detecta cuando se pasa de un bit a otro, debo determinar si step es 6 u 11 dependiendo de si es 0 o 1 el bit.
		if (counter % LENXBIT == 0)
		{
			//int test = uartData[(int)(counter/LENXBIT)];
			//Si en uartdata hay un 1 el step queda de 6 en 6
			if (uartData[(int)(counter/LENXBIT)])
			{
				step = SINE_1200_OFFSET;
			}
			else //Sino va de 11 en 11
			{
				step = SINE_2200_OFFSET;
			}
		}

		//uint16_t test2 = sine[index];
		DAC_setData(sine[index]);
		counter++;
		index += step;
		index %= 660;
	}
	else if(counter >= MSGLEN) //Proceso la siguiente palabra que viene.
	{
		if(get_Queue_Status_uint8(&buffer))
		{
			uint8_t data = pull_Queue_Element_uint8(&buffer);
			create_bit_frame(data);
			counter = 0;
			//index = 0;
		}
		else //Pasa a estado idle
		{
			DAC_setData(sine[index]);
			index += SINE_1200_OFFSET;
			index %= 660;
		}
	}


}


/*******************************************************************************
 ******************************************************************************/
